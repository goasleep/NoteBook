# V8工作原理
## 数据是如何存储的？
- 栈空间
1. 通常用来存放一些原始类型的小数据
- 堆空间
1. 通常用来存放引用类型的数据

## 垃圾回收
### 代际假说
1. 大部分对象在内存中存在的时间很短
2. 不死对象就会获得很久
### 新生代和老生代
1. 生存时间短的对象放在新生代
2. 生存时间久的对象放在老生代
3. 新生代和老生代分别使用不同的垃圾回收机制
   1. 新生代使用副垃圾回收机制
   2. 老生带使用主垃圾回收机制

### 垃圾回收器的工作流程
#### 副垃圾回收器
1. 使用scavenge算法，把新生代划分为两个区域，一半是对象区域，一半是空闲区域
2. 当对象空间快满的时候，才执行对象回收操作
3. 首先对对象区域的垃圾做标记
4. 标记完后，将活着的对象移到空闲区域，同时有序的排列起来
5. 完成复制后，对象区域和空间区域进行互换
#### 主垃圾回收器
1. 使用标记-整理算法

#### 垃圾回收的全停顿
- 进行一次标记-清理-整理，需要一段时间。这种行为就是全停顿，影响应用的性能和响应能力
- 为了降低老生代垃圾回收造成的卡顿。V8使用增量标记算法，将垃圾回收标记和应用逻辑交替执行，直到标记阶段完成。

## V8如何执行一段代码
1. 生成抽象语法树(AST)和执行上下文
   1. 词法分析
   2. 语法分析
2. 生成字节码
   1. 解释器Ignition会根据AST生成字节码，并执行字节码
3. 执行代码
   1. 生成字节码之后，解释器Ignition会逐条解释执行。
   2. 如果发现有热点代码(一段代码被重复执行多次),编译器TurboFan会把这段热点的字节码编译成机器码
   3. 当这段代码再次被执行的时候，执行编译后的机器码就可以了(JIT技术)
   