## Redis为什么这么快
1. 完全基于内存，绝大部分请求时纯粹的基于内存操作
2. 数据结构简单，对数据的操作也相对简单
3. 采用单线程，避免不必要的上下文切换和竞争条件，不存在多进程或者多线程的切换消耗CPU，不必考虑各种锁的问题，不存在加锁释放锁的操作，同时避免因为死锁而导致的性能消耗
4. 使用多路I/O，非阻塞IO
5. Redis直接构建里VM机制。如果使用一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

## 持久化数据和缓存如何扩容
- 如果Redis被当做缓存使用，使用**一致性哈希**实现动态扩容缩容。
- 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。

## Redis事务支持隔离性吗？
Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。

## Redis事务保证原子性吗，支持回滚吗
Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。